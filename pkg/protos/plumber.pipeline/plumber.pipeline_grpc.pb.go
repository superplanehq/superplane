// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.3.0
// source: plumber.pipeline.proto

package plumber_pipeline

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PipelineService_Schedule_FullMethodName          = "/InternalApi.Plumber.PipelineService/Schedule"
	PipelineService_Describe_FullMethodName          = "/InternalApi.Plumber.PipelineService/Describe"
	PipelineService_DescribeMany_FullMethodName      = "/InternalApi.Plumber.PipelineService/DescribeMany"
	PipelineService_DescribeTopology_FullMethodName  = "/InternalApi.Plumber.PipelineService/DescribeTopology"
	PipelineService_Terminate_FullMethodName         = "/InternalApi.Plumber.PipelineService/Terminate"
	PipelineService_ListKeyset_FullMethodName        = "/InternalApi.Plumber.PipelineService/ListKeyset"
	PipelineService_List_FullMethodName              = "/InternalApi.Plumber.PipelineService/List"
	PipelineService_ListGrouped_FullMethodName       = "/InternalApi.Plumber.PipelineService/ListGrouped"
	PipelineService_ListQueues_FullMethodName        = "/InternalApi.Plumber.PipelineService/ListQueues"
	PipelineService_ListActivity_FullMethodName      = "/InternalApi.Plumber.PipelineService/ListActivity"
	PipelineService_ListRequesters_FullMethodName    = "/InternalApi.Plumber.PipelineService/ListRequesters"
	PipelineService_RunNow_FullMethodName            = "/InternalApi.Plumber.PipelineService/RunNow"
	PipelineService_GetProjectId_FullMethodName      = "/InternalApi.Plumber.PipelineService/GetProjectId"
	PipelineService_ValidateYaml_FullMethodName      = "/InternalApi.Plumber.PipelineService/ValidateYaml"
	PipelineService_ScheduleExtension_FullMethodName = "/InternalApi.Plumber.PipelineService/ScheduleExtension"
	PipelineService_Delete_FullMethodName            = "/InternalApi.Plumber.PipelineService/Delete"
	PipelineService_PartialRebuild_FullMethodName    = "/InternalApi.Plumber.PipelineService/PartialRebuild"
	PipelineService_Version_FullMethodName           = "/InternalApi.Plumber.PipelineService/Version"
)

// PipelineServiceClient is the client API for PipelineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Pipeline service API specification.
type PipelineServiceClient interface {
	// This operation is depricated by Workflow.schedule()
	// Operation is called to schedule pipeline run.
	// Operation is synchronous and idempotent.
	Schedule(ctx context.Context, in *ScheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error)
	// Operation is called to check the state of the previously scheduled pipeline.
	// Operation is synchronous.
	Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error)
	// Operation is called to check the state of the previously scheduled pipelines.
	// Operation is synchronous.
	DescribeMany(ctx context.Context, in *DescribeManyRequest, opts ...grpc.CallOption) (*DescribeManyResponse, error)
	// Operation is called to get the Pipeline topology.
	// Operation is synchronous.
	DescribeTopology(ctx context.Context, in *DescribeTopologyRequest, opts ...grpc.CallOption) (*DescribeTopologyResponse, error)
	// Operation is called to abort previously scheduled pipeline.
	// Operation is synchronous and idempotent.
	Terminate(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error)
	// Operation is called to get all pipelines which match given search parameters.
	// Results are paginated using keyset instead of offset.
	// Operation is synchronous.
	ListKeyset(ctx context.Context, in *ListKeysetRequest, opts ...grpc.CallOption) (*ListKeysetResponse, error)
	// Operation is called to get all pipelines which match given search parameters.
	// Operation is synchronous.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// Operation is called to get one latest pipeline per each queue.
	// Operation is synchronous.
	ListGrouped(ctx context.Context, in *ListGroupedRequest, opts ...grpc.CallOption) (*ListGroupedResponse, error)
	// Operation is called to get all queues that match search criteria.
	// Operation is synchronous.
	ListQueues(ctx context.Context, in *ListQueuesRequest, opts ...grpc.CallOption) (*ListQueuesResponse, error)
	// Operation is called to get details of all running or queuing pipelines in
	// the given organization.
	// Operation is synchronous.
	ListActivity(ctx context.Context, in *ListActivityRequest, opts ...grpc.CallOption) (*ListActivityResponse, error)
	// Operation is called to get a list of pipeline requesters.
	// Operation is synchronous.
	ListRequesters(ctx context.Context, in *ListRequestersRequest, opts ...grpc.CallOption) (*ListRequestersResponse, error)
	// Operations is called to increase execution priority of job, block or pipeline.
	// Operation is asynchronous and idempotent.
	RunNow(ctx context.Context, in *RunNowRequest, opts ...grpc.CallOption) (*RunNowResponse, error)
	// Operation is called to get project_id for pipeline with given ppl_id
	// Operation is synchronous.
	GetProjectId(ctx context.Context, in *GetProjectIdRequest, opts ...grpc.CallOption) (*GetProjectIdResponse, error)
	// Operation is called to validate and potentially schedule passed pipeline yaml
	// definition.
	// Operation is synchronous.
	ValidateYaml(ctx context.Context, in *ValidateYamlRequest, opts ...grpc.CallOption) (*ValidateYamlResponse, error)
	// Operation is called to schedule pipeline defined in given yaml file for project,
	// repo, branch and commit which are taken from pipeline with given ppl_id.
	// Operation is synchronous and idempotent.
	ScheduleExtension(ctx context.Context, in *ScheduleExtensionRequest, opts ...grpc.CallOption) (*ScheduleExtensionResponse, error)
	// Delete all data regarding pipeline execution
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// It will schedule new pipeline based on given one which will only run blocks which
	// execution failed in original pipeline.
	PartialRebuild(ctx context.Context, in *PartialRebuildRequest, opts ...grpc.CallOption) (*PartialRebuildResponse, error)
	// Operation returns string representing version of the pipeline service.
	// Operation is synchronous.
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
}

type pipelineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPipelineServiceClient(cc grpc.ClientConnInterface) PipelineServiceClient {
	return &pipelineServiceClient{cc}
}

func (c *pipelineServiceClient) Schedule(ctx context.Context, in *ScheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleResponse)
	err := c.cc.Invoke(ctx, PipelineService_Schedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeResponse)
	err := c.cc.Invoke(ctx, PipelineService_Describe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) DescribeMany(ctx context.Context, in *DescribeManyRequest, opts ...grpc.CallOption) (*DescribeManyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeManyResponse)
	err := c.cc.Invoke(ctx, PipelineService_DescribeMany_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) DescribeTopology(ctx context.Context, in *DescribeTopologyRequest, opts ...grpc.CallOption) (*DescribeTopologyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeTopologyResponse)
	err := c.cc.Invoke(ctx, PipelineService_DescribeTopology_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) Terminate(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateResponse)
	err := c.cc.Invoke(ctx, PipelineService_Terminate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) ListKeyset(ctx context.Context, in *ListKeysetRequest, opts ...grpc.CallOption) (*ListKeysetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKeysetResponse)
	err := c.cc.Invoke(ctx, PipelineService_ListKeyset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, PipelineService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) ListGrouped(ctx context.Context, in *ListGroupedRequest, opts ...grpc.CallOption) (*ListGroupedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupedResponse)
	err := c.cc.Invoke(ctx, PipelineService_ListGrouped_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) ListQueues(ctx context.Context, in *ListQueuesRequest, opts ...grpc.CallOption) (*ListQueuesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListQueuesResponse)
	err := c.cc.Invoke(ctx, PipelineService_ListQueues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) ListActivity(ctx context.Context, in *ListActivityRequest, opts ...grpc.CallOption) (*ListActivityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListActivityResponse)
	err := c.cc.Invoke(ctx, PipelineService_ListActivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) ListRequesters(ctx context.Context, in *ListRequestersRequest, opts ...grpc.CallOption) (*ListRequestersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRequestersResponse)
	err := c.cc.Invoke(ctx, PipelineService_ListRequesters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) RunNow(ctx context.Context, in *RunNowRequest, opts ...grpc.CallOption) (*RunNowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunNowResponse)
	err := c.cc.Invoke(ctx, PipelineService_RunNow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) GetProjectId(ctx context.Context, in *GetProjectIdRequest, opts ...grpc.CallOption) (*GetProjectIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProjectIdResponse)
	err := c.cc.Invoke(ctx, PipelineService_GetProjectId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) ValidateYaml(ctx context.Context, in *ValidateYamlRequest, opts ...grpc.CallOption) (*ValidateYamlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateYamlResponse)
	err := c.cc.Invoke(ctx, PipelineService_ValidateYaml_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) ScheduleExtension(ctx context.Context, in *ScheduleExtensionRequest, opts ...grpc.CallOption) (*ScheduleExtensionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleExtensionResponse)
	err := c.cc.Invoke(ctx, PipelineService_ScheduleExtension_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, PipelineService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) PartialRebuild(ctx context.Context, in *PartialRebuildRequest, opts ...grpc.CallOption) (*PartialRebuildResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PartialRebuildResponse)
	err := c.cc.Invoke(ctx, PipelineService_PartialRebuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineServiceClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, PipelineService_Version_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PipelineServiceServer is the server API for PipelineService service.
// All implementations should embed UnimplementedPipelineServiceServer
// for forward compatibility.
//
// Pipeline service API specification.
type PipelineServiceServer interface {
	// This operation is depricated by Workflow.schedule()
	// Operation is called to schedule pipeline run.
	// Operation is synchronous and idempotent.
	Schedule(context.Context, *ScheduleRequest) (*ScheduleResponse, error)
	// Operation is called to check the state of the previously scheduled pipeline.
	// Operation is synchronous.
	Describe(context.Context, *DescribeRequest) (*DescribeResponse, error)
	// Operation is called to check the state of the previously scheduled pipelines.
	// Operation is synchronous.
	DescribeMany(context.Context, *DescribeManyRequest) (*DescribeManyResponse, error)
	// Operation is called to get the Pipeline topology.
	// Operation is synchronous.
	DescribeTopology(context.Context, *DescribeTopologyRequest) (*DescribeTopologyResponse, error)
	// Operation is called to abort previously scheduled pipeline.
	// Operation is synchronous and idempotent.
	Terminate(context.Context, *TerminateRequest) (*TerminateResponse, error)
	// Operation is called to get all pipelines which match given search parameters.
	// Results are paginated using keyset instead of offset.
	// Operation is synchronous.
	ListKeyset(context.Context, *ListKeysetRequest) (*ListKeysetResponse, error)
	// Operation is called to get all pipelines which match given search parameters.
	// Operation is synchronous.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Operation is called to get one latest pipeline per each queue.
	// Operation is synchronous.
	ListGrouped(context.Context, *ListGroupedRequest) (*ListGroupedResponse, error)
	// Operation is called to get all queues that match search criteria.
	// Operation is synchronous.
	ListQueues(context.Context, *ListQueuesRequest) (*ListQueuesResponse, error)
	// Operation is called to get details of all running or queuing pipelines in
	// the given organization.
	// Operation is synchronous.
	ListActivity(context.Context, *ListActivityRequest) (*ListActivityResponse, error)
	// Operation is called to get a list of pipeline requesters.
	// Operation is synchronous.
	ListRequesters(context.Context, *ListRequestersRequest) (*ListRequestersResponse, error)
	// Operations is called to increase execution priority of job, block or pipeline.
	// Operation is asynchronous and idempotent.
	RunNow(context.Context, *RunNowRequest) (*RunNowResponse, error)
	// Operation is called to get project_id for pipeline with given ppl_id
	// Operation is synchronous.
	GetProjectId(context.Context, *GetProjectIdRequest) (*GetProjectIdResponse, error)
	// Operation is called to validate and potentially schedule passed pipeline yaml
	// definition.
	// Operation is synchronous.
	ValidateYaml(context.Context, *ValidateYamlRequest) (*ValidateYamlResponse, error)
	// Operation is called to schedule pipeline defined in given yaml file for project,
	// repo, branch and commit which are taken from pipeline with given ppl_id.
	// Operation is synchronous and idempotent.
	ScheduleExtension(context.Context, *ScheduleExtensionRequest) (*ScheduleExtensionResponse, error)
	// Delete all data regarding pipeline execution
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// It will schedule new pipeline based on given one which will only run blocks which
	// execution failed in original pipeline.
	PartialRebuild(context.Context, *PartialRebuildRequest) (*PartialRebuildResponse, error)
	// Operation returns string representing version of the pipeline service.
	// Operation is synchronous.
	Version(context.Context, *VersionRequest) (*VersionResponse, error)
}

// UnimplementedPipelineServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPipelineServiceServer struct{}

func (UnimplementedPipelineServiceServer) Schedule(context.Context, *ScheduleRequest) (*ScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Schedule not implemented")
}
func (UnimplementedPipelineServiceServer) Describe(context.Context, *DescribeRequest) (*DescribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Describe not implemented")
}
func (UnimplementedPipelineServiceServer) DescribeMany(context.Context, *DescribeManyRequest) (*DescribeManyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeMany not implemented")
}
func (UnimplementedPipelineServiceServer) DescribeTopology(context.Context, *DescribeTopologyRequest) (*DescribeTopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeTopology not implemented")
}
func (UnimplementedPipelineServiceServer) Terminate(context.Context, *TerminateRequest) (*TerminateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Terminate not implemented")
}
func (UnimplementedPipelineServiceServer) ListKeyset(context.Context, *ListKeysetRequest) (*ListKeysetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKeyset not implemented")
}
func (UnimplementedPipelineServiceServer) List(context.Context, *ListRequest) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPipelineServiceServer) ListGrouped(context.Context, *ListGroupedRequest) (*ListGroupedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGrouped not implemented")
}
func (UnimplementedPipelineServiceServer) ListQueues(context.Context, *ListQueuesRequest) (*ListQueuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListQueues not implemented")
}
func (UnimplementedPipelineServiceServer) ListActivity(context.Context, *ListActivityRequest) (*ListActivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListActivity not implemented")
}
func (UnimplementedPipelineServiceServer) ListRequesters(context.Context, *ListRequestersRequest) (*ListRequestersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRequesters not implemented")
}
func (UnimplementedPipelineServiceServer) RunNow(context.Context, *RunNowRequest) (*RunNowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunNow not implemented")
}
func (UnimplementedPipelineServiceServer) GetProjectId(context.Context, *GetProjectIdRequest) (*GetProjectIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectId not implemented")
}
func (UnimplementedPipelineServiceServer) ValidateYaml(context.Context, *ValidateYamlRequest) (*ValidateYamlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateYaml not implemented")
}
func (UnimplementedPipelineServiceServer) ScheduleExtension(context.Context, *ScheduleExtensionRequest) (*ScheduleExtensionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScheduleExtension not implemented")
}
func (UnimplementedPipelineServiceServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedPipelineServiceServer) PartialRebuild(context.Context, *PartialRebuildRequest) (*PartialRebuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartialRebuild not implemented")
}
func (UnimplementedPipelineServiceServer) Version(context.Context, *VersionRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedPipelineServiceServer) testEmbeddedByValue() {}

// UnsafePipelineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PipelineServiceServer will
// result in compilation errors.
type UnsafePipelineServiceServer interface {
	mustEmbedUnimplementedPipelineServiceServer()
}

func RegisterPipelineServiceServer(s grpc.ServiceRegistrar, srv PipelineServiceServer) {
	// If the following call pancis, it indicates UnimplementedPipelineServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PipelineService_ServiceDesc, srv)
}

func _PipelineService_Schedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).Schedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_Schedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).Schedule(ctx, req.(*ScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_Describe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).Describe(ctx, req.(*DescribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_DescribeMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).DescribeMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_DescribeMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).DescribeMany(ctx, req.(*DescribeManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_DescribeTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeTopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).DescribeTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_DescribeTopology_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).DescribeTopology(ctx, req.(*DescribeTopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_Terminate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).Terminate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_Terminate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).Terminate(ctx, req.(*TerminateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_ListKeyset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).ListKeyset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_ListKeyset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).ListKeyset(ctx, req.(*ListKeysetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_ListGrouped_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).ListGrouped(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_ListGrouped_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).ListGrouped(ctx, req.(*ListGroupedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_ListQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListQueuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).ListQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_ListQueues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).ListQueues(ctx, req.(*ListQueuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_ListActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).ListActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_ListActivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).ListActivity(ctx, req.(*ListActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_ListRequesters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequestersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).ListRequesters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_ListRequesters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).ListRequesters(ctx, req.(*ListRequestersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_RunNow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunNowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).RunNow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_RunNow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).RunNow(ctx, req.(*RunNowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_GetProjectId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).GetProjectId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_GetProjectId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).GetProjectId(ctx, req.(*GetProjectIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_ValidateYaml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).ValidateYaml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_ValidateYaml_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).ValidateYaml(ctx, req.(*ValidateYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_ScheduleExtension_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleExtensionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).ScheduleExtension(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_ScheduleExtension_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).ScheduleExtension(ctx, req.(*ScheduleExtensionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_PartialRebuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartialRebuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).PartialRebuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_PartialRebuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).PartialRebuild(ctx, req.(*PartialRebuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PipelineService_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineServiceServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PipelineService_ServiceDesc is the grpc.ServiceDesc for PipelineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PipelineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "InternalApi.Plumber.PipelineService",
	HandlerType: (*PipelineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Schedule",
			Handler:    _PipelineService_Schedule_Handler,
		},
		{
			MethodName: "Describe",
			Handler:    _PipelineService_Describe_Handler,
		},
		{
			MethodName: "DescribeMany",
			Handler:    _PipelineService_DescribeMany_Handler,
		},
		{
			MethodName: "DescribeTopology",
			Handler:    _PipelineService_DescribeTopology_Handler,
		},
		{
			MethodName: "Terminate",
			Handler:    _PipelineService_Terminate_Handler,
		},
		{
			MethodName: "ListKeyset",
			Handler:    _PipelineService_ListKeyset_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PipelineService_List_Handler,
		},
		{
			MethodName: "ListGrouped",
			Handler:    _PipelineService_ListGrouped_Handler,
		},
		{
			MethodName: "ListQueues",
			Handler:    _PipelineService_ListQueues_Handler,
		},
		{
			MethodName: "ListActivity",
			Handler:    _PipelineService_ListActivity_Handler,
		},
		{
			MethodName: "ListRequesters",
			Handler:    _PipelineService_ListRequesters_Handler,
		},
		{
			MethodName: "RunNow",
			Handler:    _PipelineService_RunNow_Handler,
		},
		{
			MethodName: "GetProjectId",
			Handler:    _PipelineService_GetProjectId_Handler,
		},
		{
			MethodName: "ValidateYaml",
			Handler:    _PipelineService_ValidateYaml_Handler,
		},
		{
			MethodName: "ScheduleExtension",
			Handler:    _PipelineService_ScheduleExtension_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _PipelineService_Delete_Handler,
		},
		{
			MethodName: "PartialRebuild",
			Handler:    _PipelineService_PartialRebuild_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _PipelineService_Version_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plumber.pipeline.proto",
}
