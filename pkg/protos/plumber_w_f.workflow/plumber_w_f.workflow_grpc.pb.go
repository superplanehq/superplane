// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.3.0
// source: plumber_w_f.workflow.proto

package plumber_w_f_workflow

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WorkflowService_Schedule_FullMethodName            = "/InternalApi.PlumberWF.WorkflowService/Schedule"
	WorkflowService_GetPath_FullMethodName             = "/InternalApi.PlumberWF.WorkflowService/GetPath"
	WorkflowService_List_FullMethodName                = "/InternalApi.PlumberWF.WorkflowService/List"
	WorkflowService_ListKeyset_FullMethodName          = "/InternalApi.PlumberWF.WorkflowService/ListKeyset"
	WorkflowService_ListGrouped_FullMethodName         = "/InternalApi.PlumberWF.WorkflowService/ListGrouped"
	WorkflowService_ListGroupedKS_FullMethodName       = "/InternalApi.PlumberWF.WorkflowService/ListGroupedKS"
	WorkflowService_ListLatestWorkflows_FullMethodName = "/InternalApi.PlumberWF.WorkflowService/ListLatestWorkflows"
	WorkflowService_Describe_FullMethodName            = "/InternalApi.PlumberWF.WorkflowService/Describe"
	WorkflowService_DescribeMany_FullMethodName        = "/InternalApi.PlumberWF.WorkflowService/DescribeMany"
	WorkflowService_Terminate_FullMethodName           = "/InternalApi.PlumberWF.WorkflowService/Terminate"
	WorkflowService_ListLabels_FullMethodName          = "/InternalApi.PlumberWF.WorkflowService/ListLabels"
	WorkflowService_Reschedule_FullMethodName          = "/InternalApi.PlumberWF.WorkflowService/Reschedule"
	WorkflowService_GetProjectId_FullMethodName        = "/InternalApi.PlumberWF.WorkflowService/GetProjectId"
	WorkflowService_Create_FullMethodName              = "/InternalApi.PlumberWF.WorkflowService/Create"
)

// WorkflowServiceClient is the client API for WorkflowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Pipeline service API specification.
type WorkflowServiceClient interface {
	// Operation is called to create new workflow and to schedule pipeline run in it.
	// Operation is asynchronous and idempotent.
	Schedule(ctx context.Context, in *ScheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error)
	// Operation is called to get the workflow path - list of sequential pipelines.
	// Operation is synchronous.
	GetPath(ctx context.Context, in *GetPathRequest, opts ...grpc.CallOption) (*GetPathResponse, error)
	// DEPRECATED - uses offset based pagination that does not scale
	//
	// Operation is called to get all workflows which match given search parameters.
	// Operation is synchronous.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// Operation is called to get all workflows which match given search parameters.
	// Results are paginated using keyset instead of offset.
	// Operation is synchronous.
	ListKeyset(ctx context.Context, in *ListKeysetRequest, opts ...grpc.CallOption) (*ListKeysetResponse, error)
	// Operation is called to get one latest workflow per branch/tag/pull request.
	// Operation is synchronous.
	ListGrouped(ctx context.Context, in *ListGroupedRequest, opts ...grpc.CallOption) (*ListGroupedResponse, error)
	// Operation is called to get one latest workflow per branch/tag/pull request.
	// Results are paginated using keyset instead of offset pagination.
	// Operation is synchronous.
	ListGroupedKS(ctx context.Context, in *ListGroupedKSRequest, opts ...grpc.CallOption) (*ListGroupedKSResponse, error)
	// Operation is called to get one latest workflow per branch/tag/pull request.
	// Results are paginated using keyset instead of offset pagination.
	// Operation is synchronous.
	//
	// Note: In contrast with ListGroupedKS, ListLatestWorkflows is optimized for speed.
	ListLatestWorkflows(ctx context.Context, in *ListLatestWorkflowsRequest, opts ...grpc.CallOption) (*ListLatestWorkflowsResponse, error)
	// Operation is called to get details of previously scheduled workflow.
	// Operation is synchronous.
	Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error)
	// Operation is called to get details of previously scheduled workflows.
	// Operation is synchronous.
	DescribeMany(ctx context.Context, in *DescribeManyRequest, opts ...grpc.CallOption) (*DescribeManyResponse, error)
	// Operation is called to stop all currently active pipelines in the workflow.
	// Operation is asynchronous and idempotent.
	Terminate(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error)
	// Operation is called to get all labels in a project.
	// Operation is synchronous.
	ListLabels(ctx context.Context, in *ListLabelsRequest, opts ...grpc.CallOption) (*ListLabelsResponse, error)
	// Operation is called to schedule new workflow based on already existing,
	// probably failed workflow.
	// Operation is asynchronous and idempotent.
	Reschedule(ctx context.Context, in *RescheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error)
	// Operation is called to get project_id for workflow with given wf_id
	// Operation is synchronous.
	GetProjectId(ctx context.Context, in *GetProjectIdRequest, opts ...grpc.CallOption) (*GetProjectIdResponse, error)
	// This is early stage prototype.
	// This call is intended to replace Schedule. It creates workflow.
	// This operation is called by listener_proxy.
	// Operation is asynchronous and idempotent.
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
}

type workflowServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowServiceClient(cc grpc.ClientConnInterface) WorkflowServiceClient {
	return &workflowServiceClient{cc}
}

func (c *workflowServiceClient) Schedule(ctx context.Context, in *ScheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_Schedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetPath(ctx context.Context, in *GetPathRequest, opts ...grpc.CallOption) (*GetPathResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPathResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetPath_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, WorkflowService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListKeyset(ctx context.Context, in *ListKeysetRequest, opts ...grpc.CallOption) (*ListKeysetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKeysetResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListKeyset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListGrouped(ctx context.Context, in *ListGroupedRequest, opts ...grpc.CallOption) (*ListGroupedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupedResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListGrouped_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListGroupedKS(ctx context.Context, in *ListGroupedKSRequest, opts ...grpc.CallOption) (*ListGroupedKSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupedKSResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListGroupedKS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListLatestWorkflows(ctx context.Context, in *ListLatestWorkflowsRequest, opts ...grpc.CallOption) (*ListLatestWorkflowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLatestWorkflowsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListLatestWorkflows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeResponse)
	err := c.cc.Invoke(ctx, WorkflowService_Describe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeMany(ctx context.Context, in *DescribeManyRequest, opts ...grpc.CallOption) (*DescribeManyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeManyResponse)
	err := c.cc.Invoke(ctx, WorkflowService_DescribeMany_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) Terminate(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateResponse)
	err := c.cc.Invoke(ctx, WorkflowService_Terminate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListLabels(ctx context.Context, in *ListLabelsRequest, opts ...grpc.CallOption) (*ListLabelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLabelsResponse)
	err := c.cc.Invoke(ctx, WorkflowService_ListLabels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) Reschedule(ctx context.Context, in *RescheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleResponse)
	err := c.cc.Invoke(ctx, WorkflowService_Reschedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetProjectId(ctx context.Context, in *GetProjectIdRequest, opts ...grpc.CallOption) (*GetProjectIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProjectIdResponse)
	err := c.cc.Invoke(ctx, WorkflowService_GetProjectId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, WorkflowService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowServiceServer is the server API for WorkflowService service.
// All implementations should embed UnimplementedWorkflowServiceServer
// for forward compatibility.
//
// Pipeline service API specification.
type WorkflowServiceServer interface {
	// Operation is called to create new workflow and to schedule pipeline run in it.
	// Operation is asynchronous and idempotent.
	Schedule(context.Context, *ScheduleRequest) (*ScheduleResponse, error)
	// Operation is called to get the workflow path - list of sequential pipelines.
	// Operation is synchronous.
	GetPath(context.Context, *GetPathRequest) (*GetPathResponse, error)
	// DEPRECATED - uses offset based pagination that does not scale
	//
	// Operation is called to get all workflows which match given search parameters.
	// Operation is synchronous.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Operation is called to get all workflows which match given search parameters.
	// Results are paginated using keyset instead of offset.
	// Operation is synchronous.
	ListKeyset(context.Context, *ListKeysetRequest) (*ListKeysetResponse, error)
	// Operation is called to get one latest workflow per branch/tag/pull request.
	// Operation is synchronous.
	ListGrouped(context.Context, *ListGroupedRequest) (*ListGroupedResponse, error)
	// Operation is called to get one latest workflow per branch/tag/pull request.
	// Results are paginated using keyset instead of offset pagination.
	// Operation is synchronous.
	ListGroupedKS(context.Context, *ListGroupedKSRequest) (*ListGroupedKSResponse, error)
	// Operation is called to get one latest workflow per branch/tag/pull request.
	// Results are paginated using keyset instead of offset pagination.
	// Operation is synchronous.
	//
	// Note: In contrast with ListGroupedKS, ListLatestWorkflows is optimized for speed.
	ListLatestWorkflows(context.Context, *ListLatestWorkflowsRequest) (*ListLatestWorkflowsResponse, error)
	// Operation is called to get details of previously scheduled workflow.
	// Operation is synchronous.
	Describe(context.Context, *DescribeRequest) (*DescribeResponse, error)
	// Operation is called to get details of previously scheduled workflows.
	// Operation is synchronous.
	DescribeMany(context.Context, *DescribeManyRequest) (*DescribeManyResponse, error)
	// Operation is called to stop all currently active pipelines in the workflow.
	// Operation is asynchronous and idempotent.
	Terminate(context.Context, *TerminateRequest) (*TerminateResponse, error)
	// Operation is called to get all labels in a project.
	// Operation is synchronous.
	ListLabels(context.Context, *ListLabelsRequest) (*ListLabelsResponse, error)
	// Operation is called to schedule new workflow based on already existing,
	// probably failed workflow.
	// Operation is asynchronous and idempotent.
	Reschedule(context.Context, *RescheduleRequest) (*ScheduleResponse, error)
	// Operation is called to get project_id for workflow with given wf_id
	// Operation is synchronous.
	GetProjectId(context.Context, *GetProjectIdRequest) (*GetProjectIdResponse, error)
	// This is early stage prototype.
	// This call is intended to replace Schedule. It creates workflow.
	// This operation is called by listener_proxy.
	// Operation is asynchronous and idempotent.
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
}

// UnimplementedWorkflowServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowServiceServer struct{}

func (UnimplementedWorkflowServiceServer) Schedule(context.Context, *ScheduleRequest) (*ScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Schedule not implemented")
}
func (UnimplementedWorkflowServiceServer) GetPath(context.Context, *GetPathRequest) (*GetPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPath not implemented")
}
func (UnimplementedWorkflowServiceServer) List(context.Context, *ListRequest) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedWorkflowServiceServer) ListKeyset(context.Context, *ListKeysetRequest) (*ListKeysetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKeyset not implemented")
}
func (UnimplementedWorkflowServiceServer) ListGrouped(context.Context, *ListGroupedRequest) (*ListGroupedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGrouped not implemented")
}
func (UnimplementedWorkflowServiceServer) ListGroupedKS(context.Context, *ListGroupedKSRequest) (*ListGroupedKSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroupedKS not implemented")
}
func (UnimplementedWorkflowServiceServer) ListLatestWorkflows(context.Context, *ListLatestWorkflowsRequest) (*ListLatestWorkflowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLatestWorkflows not implemented")
}
func (UnimplementedWorkflowServiceServer) Describe(context.Context, *DescribeRequest) (*DescribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Describe not implemented")
}
func (UnimplementedWorkflowServiceServer) DescribeMany(context.Context, *DescribeManyRequest) (*DescribeManyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeMany not implemented")
}
func (UnimplementedWorkflowServiceServer) Terminate(context.Context, *TerminateRequest) (*TerminateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Terminate not implemented")
}
func (UnimplementedWorkflowServiceServer) ListLabels(context.Context, *ListLabelsRequest) (*ListLabelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLabels not implemented")
}
func (UnimplementedWorkflowServiceServer) Reschedule(context.Context, *RescheduleRequest) (*ScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reschedule not implemented")
}
func (UnimplementedWorkflowServiceServer) GetProjectId(context.Context, *GetProjectIdRequest) (*GetProjectIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectId not implemented")
}
func (UnimplementedWorkflowServiceServer) Create(context.Context, *CreateRequest) (*CreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedWorkflowServiceServer) testEmbeddedByValue() {}

// UnsafeWorkflowServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowServiceServer will
// result in compilation errors.
type UnsafeWorkflowServiceServer interface {
	mustEmbedUnimplementedWorkflowServiceServer()
}

func RegisterWorkflowServiceServer(s grpc.ServiceRegistrar, srv WorkflowServiceServer) {
	// If the following call pancis, it indicates UnimplementedWorkflowServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowService_ServiceDesc, srv)
}

func _WorkflowService_Schedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).Schedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_Schedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).Schedule(ctx, req.(*ScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetPath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetPath(ctx, req.(*GetPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListKeyset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListKeyset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListKeyset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListKeyset(ctx, req.(*ListKeysetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListGrouped_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListGrouped(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListGrouped_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListGrouped(ctx, req.(*ListGroupedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListGroupedKS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupedKSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListGroupedKS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListGroupedKS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListGroupedKS(ctx, req.(*ListGroupedKSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListLatestWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLatestWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListLatestWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListLatestWorkflows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListLatestWorkflows(ctx, req.(*ListLatestWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_Describe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).Describe(ctx, req.(*DescribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_DescribeMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeMany(ctx, req.(*DescribeManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_Terminate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).Terminate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_Terminate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).Terminate(ctx, req.(*TerminateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLabelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_ListLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListLabels(ctx, req.(*ListLabelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_Reschedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RescheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).Reschedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_Reschedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).Reschedule(ctx, req.(*RescheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetProjectId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetProjectId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_GetProjectId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetProjectId(ctx, req.(*GetProjectIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkflowService_ServiceDesc is the grpc.ServiceDesc for WorkflowService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "InternalApi.PlumberWF.WorkflowService",
	HandlerType: (*WorkflowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Schedule",
			Handler:    _WorkflowService_Schedule_Handler,
		},
		{
			MethodName: "GetPath",
			Handler:    _WorkflowService_GetPath_Handler,
		},
		{
			MethodName: "List",
			Handler:    _WorkflowService_List_Handler,
		},
		{
			MethodName: "ListKeyset",
			Handler:    _WorkflowService_ListKeyset_Handler,
		},
		{
			MethodName: "ListGrouped",
			Handler:    _WorkflowService_ListGrouped_Handler,
		},
		{
			MethodName: "ListGroupedKS",
			Handler:    _WorkflowService_ListGroupedKS_Handler,
		},
		{
			MethodName: "ListLatestWorkflows",
			Handler:    _WorkflowService_ListLatestWorkflows_Handler,
		},
		{
			MethodName: "Describe",
			Handler:    _WorkflowService_Describe_Handler,
		},
		{
			MethodName: "DescribeMany",
			Handler:    _WorkflowService_DescribeMany_Handler,
		},
		{
			MethodName: "Terminate",
			Handler:    _WorkflowService_Terminate_Handler,
		},
		{
			MethodName: "ListLabels",
			Handler:    _WorkflowService_ListLabels_Handler,
		},
		{
			MethodName: "Reschedule",
			Handler:    _WorkflowService_Reschedule_Handler,
		},
		{
			MethodName: "GetProjectId",
			Handler:    _WorkflowService_GetProjectId_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _WorkflowService_Create_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plumber_w_f.workflow.proto",
}
