package grafana

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/superplanehq/superplane/pkg/configuration"
	"github.com/superplanehq/superplane/pkg/core"
)

type OnAlertFiring struct{}

func (t *OnAlertFiring) Name() string {
	return "grafana.onAlertFiring"
}

func (t *OnAlertFiring) Label() string {
	return "On Alert Firing"
}

func (t *OnAlertFiring) Description() string {
	return "Trigger when a Grafana alert rule is firing"
}

func (t *OnAlertFiring) Documentation() string {
	return `The On Alert Firing trigger starts a workflow when Grafana Unified Alerting sends a firing alert webhook.

## Setup

1. Create a contact point in Grafana (Alerting > Contact points) with type Webhook.
2. Use the webhook URL generated by SuperPlane for this trigger.
3. Make sure the alert rule routes to that contact point.

## Event Data

The trigger emits the full Grafana webhook payload, including:
- status (firing/resolved)
- alerts array with labels and annotations
- groupLabels, commonLabels, commonAnnotations
- externalURL and other alerting metadata
`
}

func (t *OnAlertFiring) Icon() string {
	return "alert-triangle"
}

func (t *OnAlertFiring) Color() string {
	return "gray"
}

func (t *OnAlertFiring) Configuration() []configuration.Field {
	return []configuration.Field{}
}

func (t *OnAlertFiring) Setup(ctx core.TriggerContext) error {
	if err := ctx.Integration.RequestWebhook(struct{}{}); err != nil {
		return err
	}

	if err := setWebhookURLMetadata(ctx); err != nil {
		ctx.Logger.Warnf("grafana onAlertFiring: failed to store webhook url metadata: %v", err)
	}

	return nil
}

func (t *OnAlertFiring) Actions() []core.Action {
	return []core.Action{}
}

func (t *OnAlertFiring) HandleAction(ctx core.TriggerActionContext) (map[string]any, error) {
	return nil, nil
}

func (t *OnAlertFiring) HandleWebhook(ctx core.WebhookRequestContext) (int, error) {
	if len(ctx.Body) == 0 {
		return http.StatusBadRequest, fmt.Errorf("empty body")
	}

	var payload map[string]any
	if err := json.Unmarshal(ctx.Body, &payload); err != nil {
		return http.StatusBadRequest, fmt.Errorf("error parsing request body: %v", err)
	}

	if !isFiringAlert(payload) {
		return http.StatusOK, nil
	}

	if err := ctx.Events.Emit("grafana.alert.firing", payload); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("error emitting event: %v", err)
	}

	return http.StatusOK, nil
}

func (t *OnAlertFiring) Cleanup(ctx core.TriggerContext) error {
	return nil
}

func isFiringAlert(payload map[string]any) bool {
	status := extractString(payload["status"])
	if strings.EqualFold(status, "firing") {
		return true
	}

	alerts, ok := payload["alerts"]
	if !ok {
		return false
	}

	alertList, ok := alerts.([]any)
	if !ok {
		return false
	}

	for _, item := range alertList {
		alert, ok := item.(map[string]any)
		if !ok {
			continue
		}
		if strings.EqualFold(extractString(alert["status"]), "firing") {
			return true
		}
	}

	return false
}

func extractString(value any) string {
	text, ok := value.(string)
	if !ok {
		return ""
	}
	return strings.TrimSpace(text)
}

func setWebhookURLMetadata(ctx core.TriggerContext) error {
	webhookURL, err := ctx.Webhook.GetURL()
	if err != nil {
		return err
	}

	metadata := map[string]any{}
	if existing := ctx.Metadata.Get(); existing != nil {
		if existingMap, ok := existing.(map[string]any); ok {
			for key, value := range existingMap {
				metadata[key] = value
			}
		}
	}

	metadata["webhookUrl"] = webhookURL
	return ctx.Metadata.Set(metadata)
}
